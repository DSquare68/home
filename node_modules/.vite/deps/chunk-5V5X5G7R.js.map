{
  "version": 3,
  "sources": ["../../@vaadin/overlay/src/vaadin-overlay-stack-mixin.js"],
  "sourcesContent": ["/**\n * @license\n * Copyright (c) 2017 - 2025 Vaadin Ltd.\n * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/\n */\n\n/**\n * Returns all attached overlays in visual stacking order.\n * @private\n */\nconst getAttachedInstances = () =>\n  Array.from(document.body.children)\n    .filter((el) => el instanceof HTMLElement && el._hasOverlayStackMixin && !el.hasAttribute('closing'))\n    .sort((a, b) => a.__zIndex - b.__zIndex || 0);\n\n/**\n * Returns all attached overlay instances excluding notification container,\n * which only needs to be in the stack for zIndex but not pointer-events.\n * @private\n */\nconst getOverlayInstances = () => getAttachedInstances().filter((el) => el.$.overlay);\n\n/**\n * Returns true if the overlay is the last one in the opened overlays stack.\n * @param {HTMLElement} overlay\n * @param {function(HTMLElement): boolean} filter\n * @return {boolean}\n * @protected\n */\nexport const isLastOverlay = (overlay, filter = (_overlay) => true) => {\n  const filteredOverlays = getOverlayInstances().filter(filter);\n  return overlay === filteredOverlays.pop();\n};\n\nconst overlayMap = new WeakMap();\n\n/**\n * Stores the reference to the nested overlay for given parent,\n * or removes it when the nested overlay is null.\n * @param {HTMLElement} parent\n * @param {HTMLElement} nested\n * @protected\n */\nexport const setNestedOverlay = (parent, nested) => {\n  if (nested != null) {\n    overlayMap.set(parent, nested);\n  } else {\n    overlayMap.delete(parent);\n  }\n};\n\n/**\n * @polymerMixin\n */\nexport const OverlayStackMixin = (superClass) =>\n  class OverlayStackMixin extends superClass {\n    constructor() {\n      super();\n\n      this._hasOverlayStackMixin = true;\n    }\n\n    /**\n     * Returns true if this is the last one in the opened overlays stack.\n     *\n     * @return {boolean}\n     * @protected\n     */\n    get _last() {\n      return isLastOverlay(this);\n    }\n\n    /**\n     * Brings the overlay as visually the frontmost one.\n     */\n    bringToFront() {\n      let zIndex = '';\n      const frontmost = getAttachedInstances()\n        .filter((o) => o !== this)\n        .pop();\n      if (frontmost) {\n        const frontmostZIndex = frontmost.__zIndex;\n        zIndex = frontmostZIndex + 1;\n      }\n      this.style.zIndex = zIndex;\n      this.__zIndex = zIndex || parseFloat(getComputedStyle(this).zIndex);\n\n      // If there is a nested overlay, call `bringToFront()` for it as well.\n      if (overlayMap.has(this)) {\n        overlayMap.get(this).bringToFront();\n      }\n    }\n\n    /** @protected */\n    _enterModalState() {\n      if (document.body.style.pointerEvents !== 'none') {\n        // Set body pointer-events to 'none' to disable mouse interactions with\n        // other document nodes.\n        this._previousDocumentPointerEvents = document.body.style.pointerEvents;\n        document.body.style.pointerEvents = 'none';\n      }\n\n      // Disable pointer events in other attached overlays\n      getOverlayInstances().forEach((el) => {\n        if (el !== this) {\n          el.$.overlay.style.pointerEvents = 'none';\n        }\n      });\n    }\n\n    /** @protected */\n    _exitModalState() {\n      if (this._previousDocumentPointerEvents !== undefined) {\n        // Restore body pointer-events\n        document.body.style.pointerEvents = this._previousDocumentPointerEvents;\n        delete this._previousDocumentPointerEvents;\n      }\n\n      // Restore pointer events in the previous overlay(s)\n      const instances = getOverlayInstances();\n\n      let el;\n      // Use instances.pop() to ensure the reverse order\n      while ((el = instances.pop())) {\n        if (el === this) {\n          // Skip the current instance\n          continue;\n        }\n        el.$.overlay.style.removeProperty('pointer-events');\n        if (!el.modeless) {\n          // Stop after the last modal\n          break;\n        }\n      }\n    }\n  };\n"],
  "mappings": ";AAUA,IAAM,uBAAuB,MAC3B,MAAM,KAAK,SAAS,KAAK,QAAQ,EAC9B,OAAO,CAAC,OAAO,cAAc,eAAe,GAAG,yBAAyB,CAAC,GAAG,aAAa,SAAS,CAAC,EACnG,KAAK,CAAC,GAAG,MAAM,EAAE,WAAW,EAAE,YAAY,CAAC;AAOhD,IAAM,sBAAsB,MAAM,qBAAqB,EAAE,OAAO,CAAC,OAAO,GAAG,EAAE,OAAO;AAS7E,IAAM,gBAAgB,CAAC,SAAS,SAAS,CAAC,aAAa,SAAS;AACrE,QAAM,mBAAmB,oBAAoB,EAAE,OAAO,MAAM;AAC5D,SAAO,YAAY,iBAAiB,IAAI;AAC1C;AAEA,IAAM,aAAa,oBAAI,QAAQ;AASxB,IAAM,mBAAmB,CAAC,QAAQ,WAAW;AAClD,MAAI,UAAU,MAAM;AAClB,eAAW,IAAI,QAAQ,MAAM;AAAA,EAC/B,OAAO;AACL,eAAW,OAAO,MAAM;AAAA,EAC1B;AACF;AAKO,IAAM,oBAAoB,CAAC,eAChC,MAAM,0BAA0B,WAAW;AAAA,EACzC,cAAc;AACZ,UAAM;AAEN,SAAK,wBAAwB;AAAA,EAC/B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQA,IAAI,QAAQ;AACV,WAAO,cAAc,IAAI;AAAA,EAC3B;AAAA;AAAA;AAAA;AAAA,EAKA,eAAe;AACb,QAAI,SAAS;AACb,UAAM,YAAY,qBAAqB,EACpC,OAAO,CAAC,MAAM,MAAM,IAAI,EACxB,IAAI;AACP,QAAI,WAAW;AACb,YAAM,kBAAkB,UAAU;AAClC,eAAS,kBAAkB;AAAA,IAC7B;AACA,SAAK,MAAM,SAAS;AACpB,SAAK,WAAW,UAAU,WAAW,iBAAiB,IAAI,EAAE,MAAM;AAGlE,QAAI,WAAW,IAAI,IAAI,GAAG;AACxB,iBAAW,IAAI,IAAI,EAAE,aAAa;AAAA,IACpC;AAAA,EACF;AAAA;AAAA,EAGA,mBAAmB;AACjB,QAAI,SAAS,KAAK,MAAM,kBAAkB,QAAQ;AAGhD,WAAK,iCAAiC,SAAS,KAAK,MAAM;AAC1D,eAAS,KAAK,MAAM,gBAAgB;AAAA,IACtC;AAGA,wBAAoB,EAAE,QAAQ,CAAC,OAAO;AACpC,UAAI,OAAO,MAAM;AACf,WAAG,EAAE,QAAQ,MAAM,gBAAgB;AAAA,MACrC;AAAA,IACF,CAAC;AAAA,EACH;AAAA;AAAA,EAGA,kBAAkB;AAChB,QAAI,KAAK,mCAAmC,QAAW;AAErD,eAAS,KAAK,MAAM,gBAAgB,KAAK;AACzC,aAAO,KAAK;AAAA,IACd;AAGA,UAAM,YAAY,oBAAoB;AAEtC,QAAI;AAEJ,WAAQ,KAAK,UAAU,IAAI,GAAI;AAC7B,UAAI,OAAO,MAAM;AAEf;AAAA,MACF;AACA,SAAG,EAAE,QAAQ,MAAM,eAAe,gBAAgB;AAClD,UAAI,CAAC,GAAG,UAAU;AAEhB;AAAA,MACF;AAAA,IACF;AAAA,EACF;AACF;",
  "names": []
}

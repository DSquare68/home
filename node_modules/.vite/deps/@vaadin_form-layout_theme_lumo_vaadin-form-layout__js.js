import {
  formLayoutSlotStyles,
  formLayoutStyles
} from "./chunk-UXKG5W3W.js";
import {
  SlotStylesMixin
} from "./chunk-N7EECNWR.js";
import {
  ElementMixin
} from "./chunk-URF4KV3C.js";
import "./chunk-MQUER7SS.js";
import {
  isElementHidden
} from "./chunk-I6CYOH2Q.js";
import "./chunk-UEMNGQJU.js";
import "./chunk-ZXX3J6CF.js";
import "./chunk-IGJXGE7W.js";
import "./chunk-N24TFO6U.js";
import "./chunk-SWLOXKW7.js";
import "./chunk-PWAYYGHN.js";
import {
  ThemableMixin,
  registerStyles
} from "./chunk-RMQPKG57.js";
import {
  defineCustomElement
} from "./chunk-HLV3SA5Y.js";
import "./chunk-CFR7KJ7B.js";
import "./chunk-L4R6EZIQ.js";
import {
  css
} from "./chunk-JOMJT2WW.js";
import "./chunk-6YZLFVRB.js";
import {
  PolymerElement
} from "./chunk-3TSYJSTE.js";
import "./chunk-X2PW6HF6.js";
import "./chunk-XHHLOPTP.js";
import "./chunk-IIZJCMP5.js";
import "./chunk-GFCZVMCV.js";
import {
  html
} from "./chunk-XB4RSW42.js";
import "./chunk-6WL6DBHT.js";
import "./chunk-5WRI5ZAA.js";

// node_modules/@vaadin/form-layout/theme/lumo/vaadin-form-layout-styles.js
registerStyles(
  "vaadin-form-layout",
  css`
    :host {
      --vaadin-form-layout-column-spacing: var(--lumo-space-l);
      --vaadin-form-layout-row-spacing: 0;
    }
  `,
  { moduleId: "lumo-form-layout" }
);

// node_modules/@vaadin/form-layout/src/layouts/abstract-layout.js
var AbstractLayout = class {
  /**
   * @param {HTMLElement} host
   * @param {{ mutationObserverOptions: MutationObserverInit }} config
   */
  constructor(host, config) {
    this.host = host;
    this.props = {};
    this.config = config;
    this.isConnected = false;
    this.__resizeObserver = new ResizeObserver((entries) => setTimeout(() => this._onResize(entries)));
    this.__mutationObserver = new MutationObserver((records) => this._onMutation(records));
  }
  /**
   * Connects the layout to the host element.
   */
  connect() {
    if (this.isConnected) {
      return;
    }
    this.isConnected = true;
    this.__resizeObserver.observe(this.host);
    this.__mutationObserver.observe(this.host, this.config.mutationObserverOptions);
  }
  /**
   * Disconnects the layout from the host element.
   */
  disconnect() {
    if (!this.isConnected) {
      return;
    }
    this.isConnected = false;
    this.__resizeObserver.disconnect();
    this.__mutationObserver.disconnect();
  }
  /**
   * Sets the properties of the layout controller.
   */
  setProps(props) {
    this.props = props;
  }
  /**
   * Updates the layout based on the current properties.
   */
  updateLayout() {
  }
  /**
   * @param {ResizeObserverEntry[]} _entries
   * @protected
   */
  _onResize(_entries) {
  }
  /**
   * @param {MutationRecord[]} _records
   * @protected
   */
  _onMutation(_records) {
  }
};

// node_modules/@vaadin/form-layout/src/layouts/auto-responsive-layout.js
function isBreakLine(el) {
  return el.localName === "br";
}
var AutoResponsiveLayout = class extends AbstractLayout {
  constructor(host) {
    super(host, {
      mutationObserverOptions: {
        subtree: true,
        childList: true,
        attributes: true,
        attributeFilter: ["colspan", "data-colspan", "hidden"]
      }
    });
  }
  /** @override */
  connect() {
    if (this.isConnected) {
      return;
    }
    super.connect();
    this.updateLayout();
  }
  /** @override */
  disconnect() {
    if (!this.isConnected) {
      return;
    }
    super.disconnect();
    const { host } = this;
    host.style.removeProperty("--_column-width");
    host.style.removeProperty("--_max-columns");
    host.$.layout.removeAttribute("fits-labels-aside");
    host.$.layout.style.removeProperty("--_grid-rendered-column-count");
    this.__children.forEach((child) => {
      child.style.removeProperty("--_grid-colstart");
      child.style.removeProperty("--_grid-colspan");
    });
  }
  /** @override */
  setProps(props) {
    super.setProps(props);
    if (this.isConnected) {
      this.updateLayout();
    }
  }
  /** @override */
  updateLayout() {
    const { host, props } = this;
    if (!this.isConnected || isElementHidden(host)) {
      return;
    }
    let columnCount = 0;
    let maxColumns = 0;
    const children = this.__children;
    children.filter((child) => isBreakLine(child) || !isElementHidden(child)).forEach((child, index, children2) => {
      const prevChild = children2[index - 1];
      if (isBreakLine(child)) {
        columnCount = 0;
        return;
      }
      if (prevChild && prevChild.parentElement !== child.parentElement || !props.autoRows && child.parentElement === host) {
        columnCount = 0;
      }
      if (props.autoRows && columnCount === 0) {
        child.style.setProperty("--_grid-colstart", 1);
      } else {
        child.style.removeProperty("--_grid-colstart");
      }
      const colspan = child.getAttribute("colspan") || child.getAttribute("data-colspan");
      if (colspan) {
        columnCount += parseInt(colspan);
        child.style.setProperty("--_grid-colspan", colspan);
      } else {
        columnCount += 1;
        child.style.removeProperty("--_grid-colspan");
      }
      maxColumns = Math.max(maxColumns, columnCount);
    });
    children.filter(isElementHidden).forEach((child) => {
      child.style.removeProperty("--_grid-colstart");
    });
    if (props.columnWidth) {
      host.style.setProperty("--_column-width", props.columnWidth);
    } else {
      host.style.removeProperty("--_column-width");
    }
    host.style.setProperty("--_min-columns", props.minColumns);
    host.style.setProperty("--_max-columns", Math.min(Math.max(props.minColumns, props.maxColumns), maxColumns));
    host.$.layout.toggleAttribute("fits-labels-aside", this.props.labelsAside && this.__fitsLabelsAside);
    host.$.layout.style.setProperty("--_grid-rendered-column-count", this.__renderedColumnCount);
  }
  /** @override */
  _onResize() {
    this.updateLayout();
  }
  /** @override */
  _onMutation(records) {
    const shouldUpdateLayout = records.some(({ target }) => {
      return target === this.host || target.parentElement === this.host || target.parentElement.localName === "vaadin-form-row";
    });
    if (shouldUpdateLayout) {
      this.updateLayout();
    }
  }
  /** @private */
  get __children() {
    return [...this.host.children].flatMap((child) => {
      return child.localName === "vaadin-form-row" ? [...child.children] : child;
    });
  }
  /** @private */
  get __renderedColumnCount() {
    const { gridTemplateColumns } = getComputedStyle(this.host.$.layout);
    return gridTemplateColumns.split(" ").filter((width) => width !== "0px").length;
  }
  /** @private */
  get __minWidthLabelsAside() {
    const { backgroundPositionY } = getComputedStyle(this.host.$.layout, "::before");
    return parseFloat(backgroundPositionY);
  }
  /** @private */
  get __fitsLabelsAside() {
    return this.host.offsetWidth >= this.__minWidthLabelsAside;
  }
};

// node_modules/@vaadin/form-layout/src/layouts/responsive-steps-layout.js
function isValidCSSLength(value) {
  return CSS.supports("word-spacing", value) && !["inherit", "normal"].includes(value);
}
function naturalNumberOrOne(n) {
  if (typeof n === "number" && n >= 1 && n < Infinity) {
    return Math.floor(n);
  }
  return 1;
}
var ResponsiveStepsLayout = class extends AbstractLayout {
  constructor(host) {
    super(host, {
      mutationObserverOptions: {
        subtree: true,
        childList: true,
        attributes: true,
        attributeFilter: ["colspan", "data-colspan", "hidden"]
      }
    });
  }
  /** @override */
  connect() {
    if (this.isConnected) {
      return;
    }
    super.connect();
    this.__selectResponsiveStep();
    this.updateLayout();
    requestAnimationFrame(() => this.__selectResponsiveStep());
    requestAnimationFrame(() => this.updateLayout());
  }
  /** @override */
  disconnect() {
    if (!this.isConnected) {
      return;
    }
    super.disconnect();
    const { host } = this;
    host.$.layout.style.removeProperty("opacity");
    [...host.children].forEach((child) => {
      child.style.removeProperty("width");
      child.style.removeProperty("margin-left");
      child.style.removeProperty("margin-right");
      child.removeAttribute("label-position");
    });
  }
  /** @override */
  setProps(props) {
    const { responsiveSteps } = props;
    if (!Array.isArray(responsiveSteps)) {
      throw new Error('Invalid "responsiveSteps" type, an Array is required.');
    }
    if (responsiveSteps.length < 1) {
      throw new Error('Invalid empty "responsiveSteps" array, at least one item is required.');
    }
    responsiveSteps.forEach((step) => {
      if (naturalNumberOrOne(step.columns) !== step.columns) {
        throw new Error(`Invalid 'columns' value of ${step.columns}, a natural number is required.`);
      }
      if (step.minWidth !== void 0 && !isValidCSSLength(step.minWidth)) {
        throw new Error(`Invalid 'minWidth' value of ${step.minWidth}, a valid CSS length required.`);
      }
      if (step.labelsPosition !== void 0 && ["aside", "top"].indexOf(step.labelsPosition) === -1) {
        throw new Error(
          `Invalid 'labelsPosition' value of ${step.labelsPosition}, 'aside' or 'top' string is required.`
        );
      }
    });
    super.setProps(props);
    if (this.isConnected) {
      this.__selectResponsiveStep();
      this.updateLayout();
    }
  }
  /** @override */
  updateLayout() {
    const { host } = this;
    if (!this.isConnected || isElementHidden(host)) {
      return;
    }
    const style = getComputedStyle(host);
    const columnSpacing = style.getPropertyValue("--vaadin-form-layout-column-spacing");
    const direction = style.direction;
    const marginStartProp = `margin-${direction === "ltr" ? "left" : "right"}`;
    const marginEndProp = `margin-${direction === "ltr" ? "right" : "left"}`;
    const containerWidth = host.offsetWidth;
    let col = 0;
    Array.from(host.children).filter((child) => child.localName === "br" || getComputedStyle(child).display !== "none").forEach((child, index, children) => {
      if (child.localName === "br") {
        col = 0;
        return;
      }
      const attrColspan = child.getAttribute("colspan") || child.getAttribute("data-colspan");
      let colspan;
      colspan = naturalNumberOrOne(parseFloat(attrColspan));
      colspan = Math.min(colspan, this.__columnCount);
      const childRatio = colspan / this.__columnCount;
      child.style.width = `calc(${childRatio * 100}% - ${1 - childRatio} * ${columnSpacing})`;
      if (col + colspan > this.__columnCount) {
        col = 0;
      }
      if (col === 0) {
        child.style.setProperty(marginStartProp, "0px");
      } else {
        child.style.removeProperty(marginStartProp);
      }
      const nextIndex = index + 1;
      const nextLineBreak = nextIndex < children.length && children[nextIndex].localName === "br";
      if (col + colspan === this.__columnCount) {
        child.style.setProperty(marginEndProp, "0px");
      } else if (nextLineBreak) {
        const colspanRatio = (this.__columnCount - col - colspan) / this.__columnCount;
        child.style.setProperty(
          marginEndProp,
          `calc(${colspanRatio * containerWidth}px + ${colspanRatio} * ${columnSpacing})`
        );
      } else {
        child.style.removeProperty(marginEndProp);
      }
      col = (col + colspan) % this.__columnCount;
      if (child.localName === "vaadin-form-item") {
        if (this.__labelsOnTop) {
          if (child.getAttribute("label-position") !== "top") {
            child.__useLayoutLabelPosition = true;
            child.setAttribute("label-position", "top");
          }
        } else if (child.__useLayoutLabelPosition) {
          delete child.__useLayoutLabelPosition;
          child.removeAttribute("label-position");
        }
      }
    });
  }
  /** @override */
  _onResize() {
    const { host } = this;
    if (isElementHidden(host)) {
      host.$.layout.style.opacity = "0";
      return;
    }
    this.__selectResponsiveStep();
    this.updateLayout();
    host.$.layout.style.opacity = "";
  }
  /** @override */
  _onMutation(records) {
    const shouldUpdateLayout = records.some(({ target }) => {
      return target === this.host || target.parentElement === this.host;
    });
    if (shouldUpdateLayout) {
      this.updateLayout();
    }
  }
  /** @private */
  __selectResponsiveStep() {
    if (!this.isConnected) {
      return;
    }
    const { host, props } = this;
    let selectedStep;
    const tmpStyleProp = "background-position";
    props.responsiveSteps.forEach((step) => {
      host.$.layout.style.setProperty(tmpStyleProp, step.minWidth);
      const stepMinWidthPx = parseFloat(getComputedStyle(host.$.layout).getPropertyValue(tmpStyleProp));
      if (stepMinWidthPx <= host.offsetWidth) {
        selectedStep = step;
      }
    });
    host.$.layout.style.removeProperty(tmpStyleProp);
    if (selectedStep) {
      this.__columnCount = selectedStep.columns;
      this.__labelsOnTop = selectedStep.labelsPosition === "top";
    }
  }
};

// node_modules/@vaadin/form-layout/src/vaadin-form-layout-mixin.js
var FormLayoutMixin = (superClass) => class extends SlotStylesMixin(superClass) {
  static get properties() {
    return {
      /**
       * @typedef FormLayoutResponsiveStep
       * @type {object}
       * @property {string} minWidth - The threshold value for this step in CSS length units.
       * @property {number} columns - Number of columns. Only natural numbers are valid.
       * @property {string} labelsPosition - Labels position option, valid values: `"aside"` (default), `"top"`.
       */
      /**
       * Allows specifying a responsive behavior with the number of columns
       * and the label position depending on the layout width.
       *
       * Format: array of objects, each object defines one responsive step
       * with `minWidth` CSS length, `columns` number, and optional
       * `labelsPosition` string of `"aside"` or `"top"`. At least one item is required.
       *
       * NOTE: Responsive steps are ignored in auto-responsive mode, which may be
       * enabled explicitly via the `autoResponsive` property or implicitly
       * if the following feature flag is set:
       *
       * ```
       * window.Vaadin.featureFlags.defaultAutoResponsiveFormLayout = true
       * ```
       *
       * #### Examples
       *
       * ```javascript
       * formLayout.responsiveSteps = [{columns: 1}];
       * // The layout is always a single column, labels aside.
       * ```
       *
       * ```javascript
       * formLayout.responsiveSteps = [
       *   {minWidth: 0, columns: 1},
       *   {minWidth: '40em', columns: 2}
       * ];
       * // Sets two responsive steps:
       * // 1. When the layout width is < 40em, one column, labels aside.
       * // 2. Width >= 40em, two columns, labels aside.
       * ```
       *
       * ```javascript
       * formLayout.responsiveSteps = [
       *   {minWidth: 0, columns: 1, labelsPosition: 'top'},
       *   {minWidth: '20em', columns: 1},
       *   {minWidth: '40em', columns: 2}
       * ];
       * // Default value. Three responsive steps:
       * // 1. Width < 20em, one column, labels on top.
       * // 2. 20em <= width < 40em, one column, labels aside.
       * // 3. Width >= 40em, two columns, labels aside.
       * ```
       *
       * @type {!Array<!FormLayoutResponsiveStep>}
       */
      responsiveSteps: {
        type: Array,
        value() {
          return [
            { minWidth: 0, columns: 1, labelsPosition: "top" },
            { minWidth: "20em", columns: 1 },
            { minWidth: "40em", columns: 2 }
          ];
        },
        observer: "__responsiveStepsChanged",
        sync: true
      },
      /**
       * When set to `true`, the component automatically creates and adjusts columns based on
       * the container's width. Columns have a fixed width defined by `columnWidth` and their
       * number increases up to the limit set by `maxColumns`. The component dynamically adjusts
       * the number of columns as the container size changes. When this mode is enabled,
       * `responsiveSteps` are ignored.
       *
       * By default, each field is placed on a new row. To organize fields into rows, there are
       * two options:
       *
       * 1. Use `<vaadin-form-row>` to explicitly group fields into rows.
       *
       * 2. Enable the `autoRows` property to automatically arrange fields in available columns,
       *    wrapping to a new row when necessary. `<br>` elements can be used to force a new row.
       *
       * The auto-responsive mode is disabled by default. To enable it for an individual instance,
       * use this property. Alternatively, if you want it to be enabled for all instances by default,
       * enable the `defaultAutoResponsiveFormLayout` feature flag before `<vaadin-form-layout>`
       * elements are added to the DOM:
       *
       * ```js
       * window.Vaadin.featureFlags.defaultAutoResponsiveFormLayout = true;
       * ```
       *
       * @attr {boolean} auto-responsive
       */
      autoResponsive: {
        type: Boolean,
        sync: true,
        value: () => {
          if (window.Vaadin && window.Vaadin.featureFlags && window.Vaadin.featureFlags.defaultAutoResponsiveFormLayout) {
            return true;
          }
          return false;
        },
        reflectToAttribute: true
      },
      /**
       * When `autoResponsive` is enabled, defines the width of each column.
       * The value must be defined in CSS length units, e.g. `100px`.
       *
       * If the column width isn't explicitly set, it defaults to `12em`
       * or `--vaadin-field-default-width` if that CSS property is defined.
       *
       * @attr {string} column-width
       */
      columnWidth: {
        type: String,
        sync: true
      },
      /**
       * When `autoResponsive` is enabled, defines the maximum number of columns
       * that the layout can create. The layout will create columns up to this
       * limit based on the available container width.
       *
       * The default value is `10`.
       *
       * @attr {number} max-columns
       */
      maxColumns: {
        type: Number,
        sync: true,
        value: 10
      },
      /**
       * When `autoResponsive` is enabled, defines the minimum number of columns
       * that the layout can create. The layout will create columns at least up
       * to this limit.
       *
       * The default value is `1`.
       *
       * @attr {number} min-columns
       */
      minColumns: {
        type: Number,
        sync: true,
        value: 1
      },
      /**
       * When enabled with `autoResponsive`, distributes fields across columns
       * by placing each field in the next available column and wrapping to
       * the next row when the current row is full. `<br>` elements can be
       * used to force a new row.
       *
       * The default value is `false`.
       *
       * @attr {boolean} auto-rows
       */
      autoRows: {
        type: Boolean,
        sync: true,
        value: false,
        reflectToAttribute: true
      },
      /**
       * When enabled with `autoResponsive`, `<vaadin-form-item>` prefers positioning
       * labels beside the fields. If the layout is too narrow to fit a single column
       * with a side label, the component will automatically switch labels to their
       * default position above the fields.
       *
       * The default value is `false`.
       *
       * To customize the label width and the gap between the label and the field,
       * use the following CSS properties:
       *
       * - `--vaadin-form-layout-label-width`
       * - `--vaadin-form-layout-label-spacing`
       *
       * @attr {boolean} labels-aside
       */
      labelsAside: {
        type: Boolean,
        sync: true,
        value: false,
        reflectToAttribute: true
      },
      /**
       * When `autoResponsive` is enabled, specifies whether the columns should expand
       * in width to evenly fill any remaining space after all columns have been created.
       *
       * The default value is `false`.
       *
       * @attr {boolean} expand-columns
       */
      expandColumns: {
        type: Boolean,
        sync: true,
        value: false,
        reflectToAttribute: true
      },
      /**
       * When `autoResponsive` is enabled, specifies whether fields should stretch
       * to take up all available space within columns. This setting also applies
       * to fields inside `<vaadin-form-item>` elements.
       *
       * The default value is `false`.
       *
       * @attr {boolean} expand-fields
       */
      expandFields: {
        type: Boolean,
        sync: true,
        value: false,
        reflectToAttribute: true
      }
    };
  }
  static get observers() {
    return [
      "__autoResponsiveLayoutPropsChanged(columnWidth, maxColumns, minColumns, autoRows, labelsAside, expandColumns, expandFields)",
      "__autoResponsiveChanged(autoResponsive)"
    ];
  }
  constructor() {
    super();
    this.__currentLayout;
    this.__autoResponsiveLayout = new AutoResponsiveLayout(this);
    this.__responsiveStepsLayout = new ResponsiveStepsLayout(this);
  }
  /** @protected */
  connectedCallback() {
    super.connectedCallback();
    this.__currentLayout.connect();
  }
  /** @protected */
  disconnectedCallback() {
    super.disconnectedCallback();
    this.__currentLayout.disconnect();
  }
  /** @override */
  get slotStyles() {
    return [`${formLayoutSlotStyles}`.replace("vaadin-form-layout", this.localName)];
  }
  /** @protected */
  _updateLayout() {
    this.__currentLayout.updateLayout();
  }
  /** @private */
  __responsiveStepsChanged(responsiveSteps, oldResponsiveSteps) {
    try {
      this.__responsiveStepsLayout.setProps({ responsiveSteps });
    } catch (e) {
      if (oldResponsiveSteps && oldResponsiveSteps !== responsiveSteps) {
        console.warn(`${e.message} Using previously set 'responsiveSteps' instead.`);
        this.responsiveSteps = oldResponsiveSteps;
      } else {
        console.warn(`${e.message} Using default 'responsiveSteps' instead.`);
        this.responsiveSteps = [
          { minWidth: 0, columns: 1, labelsPosition: "top" },
          { minWidth: "20em", columns: 1 },
          { minWidth: "40em", columns: 2 }
        ];
      }
    }
  }
  /** @private */
  // eslint-disable-next-line @typescript-eslint/max-params
  __autoResponsiveLayoutPropsChanged(columnWidth, maxColumns, minColumns, autoRows, labelsAside, expandColumns, expandFields) {
    this.__autoResponsiveLayout.setProps({
      columnWidth,
      maxColumns,
      minColumns,
      autoRows,
      labelsAside,
      expandColumns,
      expandFields
    });
  }
  /** @private */
  __autoResponsiveChanged(autoResponsive) {
    if (this.__currentLayout) {
      this.__currentLayout.disconnect();
    }
    if (autoResponsive) {
      this.__currentLayout = this.__autoResponsiveLayout;
    } else {
      this.__currentLayout = this.__responsiveStepsLayout;
    }
    this.__currentLayout.connect();
  }
};

// node_modules/@vaadin/form-layout/src/vaadin-form-layout.js
registerStyles("vaadin-form-layout", formLayoutStyles, { moduleId: "vaadin-form-layout-styles" });
var FormLayout = class extends FormLayoutMixin(ThemableMixin(ElementMixin(PolymerElement))) {
  static get is() {
    return "vaadin-form-layout";
  }
  static get template() {
    return html`
      <div id="layout">
        <slot id="slot"></slot>
      </div>
    `;
  }
};
defineCustomElement(FormLayout);
/*! Bundled license information:

@vaadin/form-layout/src/layouts/abstract-layout.js:
@vaadin/form-layout/src/layouts/auto-responsive-layout.js:
@vaadin/form-layout/src/layouts/responsive-steps-layout.js:
  (**
   * @license
   * Copyright (c) 2021 - 2025 Vaadin Ltd.
   * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
   *)

@vaadin/form-layout/src/vaadin-form-layout-mixin.js:
@vaadin/form-layout/src/vaadin-form-layout.js:
  (**
   * @license
   * Copyright (c) 2017 - 2025 Vaadin Ltd.
   * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
   *)
*/
//# sourceMappingURL=@vaadin_form-layout_theme_lumo_vaadin-form-layout__js.js.map

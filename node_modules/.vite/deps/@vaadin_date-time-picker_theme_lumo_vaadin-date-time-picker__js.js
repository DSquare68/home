import {
  timePickerI18nDefaults
} from "./chunk-HVXA6B5L.js";
import {
  formatISOTime,
  parseISOTime,
  validateTime
} from "./chunk-7JAF3V5W.js";
import {
  customField
} from "./chunk-XYR725YH.js";
import {
  datePickerI18nDefaults
} from "./chunk-FWWVR7O3.js";
import "./chunk-3SP4GARL.js";
import {
  dateEquals,
  formatUTCISODate,
  normalizeUTCDate,
  parseUTCDate
} from "./chunk-WYQLYG5M.js";
import "./chunk-UIPSMGHU.js";
import "./chunk-5BLF2JYH.js";
import "./chunk-WDROWKSL.js";
import "./chunk-BYMC3NFR.js";
import "./chunk-GTK62YVW.js";
import "./chunk-GA2D44JO.js";
import "./chunk-NXM5LRZR.js";
import "./chunk-P73GAWRJ.js";
import {
  inputFieldShared
} from "./chunk-P3YOOBPS.js";
import "./chunk-ET67ZO6J.js";
import "./chunk-4WXHSM2N.js";
import {
  helper,
  requiredField
} from "./chunk-I76NXJ7Z.js";
import "./chunk-MIU4ENY6.js";
import "./chunk-YQVZUZLU.js";
import "./chunk-N7EECNWR.js";
import {
  FieldMixin
} from "./chunk-O2USECYE.js";
import "./chunk-KNW5SJZA.js";
import "./chunk-ZRURD2HQ.js";
import "./chunk-7GLQOZKG.js";
import "./chunk-LTK45AUZ.js";
import "./chunk-7DNYTQEN.js";
import "./chunk-524SFP4O.js";
import "./chunk-XYJL5VT6.js";
import "./chunk-YRVJI5EB.js";
import "./chunk-EB7QPD7W.js";
import "./chunk-6ROS27IT.js";
import "./chunk-CTQ6LMIA.js";
import "./chunk-EQYMNMU3.js";
import "./chunk-LYRONA3O.js";
import "./chunk-SHHEQ6FV.js";
import "./chunk-PS6K7Q2Y.js";
import "./chunk-5V5X5G7R.js";
import "./chunk-HAJJJHUK.js";
import "./chunk-AX5W53SM.js";
import "./chunk-O7YAQAXJ.js";
import "./chunk-KYS7LINF.js";
import "./chunk-OSV7EPWD.js";
import "./chunk-2VKI6DIC.js";
import "./chunk-RXJCEA2X.js";
import "./chunk-2UB7FVML.js";
import "./chunk-XDZ2Q4I2.js";
import "./chunk-CHBKIVS3.js";
import "./chunk-2TKNIALY.js";
import {
  DisabledMixin
} from "./chunk-Z3XWMGN4.js";
import "./chunk-MR3EMLXB.js";
import {
  TooltipController
} from "./chunk-A54SLGAX.js";
import {
  SlotController
} from "./chunk-LHX55C6Q.js";
import "./chunk-ZJRZFYLR.js";
import "./chunk-DBHSYCZR.js";
import {
  ElementMixin
} from "./chunk-URF4KV3C.js";
import "./chunk-MQUER7SS.js";
import "./chunk-KUB5XK2W.js";
import "./chunk-2XFOAJD3.js";
import {
  FocusMixin
} from "./chunk-2CXFKEFL.js";
import "./chunk-EFMBQXJJ.js";
import "./chunk-BZN7GALN.js";
import "./chunk-I6CYOH2Q.js";
import "./chunk-ME5JQ6XA.js";
import "./chunk-Q6EFZM3C.js";
import "./chunk-UEMNGQJU.js";
import "./chunk-ZXX3J6CF.js";
import "./chunk-IGJXGE7W.js";
import "./chunk-N24TFO6U.js";
import "./chunk-SWLOXKW7.js";
import "./chunk-PWAYYGHN.js";
import {
  ThemableMixin,
  registerStyles
} from "./chunk-RMQPKG57.js";
import {
  defineCustomElement
} from "./chunk-HLV3SA5Y.js";
import "./chunk-CFR7KJ7B.js";
import "./chunk-L4R6EZIQ.js";
import {
  css
} from "./chunk-JOMJT2WW.js";
import "./chunk-6YZLFVRB.js";
import "./chunk-HZ72CYJR.js";
import {
  PolymerElement
} from "./chunk-3TSYJSTE.js";
import "./chunk-X2PW6HF6.js";
import "./chunk-XHHLOPTP.js";
import "./chunk-R22ZSI5Y.js";
import "./chunk-IIZJCMP5.js";
import "./chunk-GFCZVMCV.js";
import {
  html
} from "./chunk-XB4RSW42.js";
import "./chunk-6WL6DBHT.js";
import "./chunk-5WRI5ZAA.js";

// node_modules/@vaadin/date-time-picker/theme/lumo/vaadin-date-time-picker-styles.js
var dateTimePicker = css`
  ::slotted([slot='date-picker']) {
    margin-inline-end: 2px;
    --vaadin-input-field-top-end-radius: 0;
    --vaadin-input-field-bottom-end-radius: 0;
  }

  ::slotted([slot='time-picker']) {
    --vaadin-input-field-top-start-radius: 0;
    --vaadin-input-field-bottom-start-radius: 0;
  }
`;
registerStyles("vaadin-date-time-picker", [dateTimePicker, requiredField, helper, customField], {
  moduleId: "lumo-date-time-picker"
});

// node_modules/@vaadin/date-time-picker/src/vaadin-date-time-picker-mixin.js
var datePickerI18nProps = Object.keys(datePickerI18nDefaults);
var timePickerI18nProps = Object.keys(timePickerI18nDefaults);
var PickerSlotController = class extends SlotController {
  constructor(host, type) {
    super(host, `${type}-picker`, `vaadin-${type}-picker`, {
      initializer: (picker, host2) => {
        const prop = `__${type}Picker`;
        host2[prop] = picker;
      }
    });
  }
};
var DateTimePickerMixin = (superClass) => class DateTimePickerMixinClass extends FieldMixin(FocusMixin(DisabledMixin(superClass))) {
  static get properties() {
    return {
      /**
       * The name of the control, which is submitted with the form data.
       */
      name: {
        type: String
      },
      /**
       * The value for this element.
       *
       * Supported date time format is based on ISO 8601 (without a time zone designator):
       * - Minute precision `"YYYY-MM-DDThh:mm"` (default)
       * - Second precision `"YYYY-MM-DDThh:mm:ss"`
       * - Millisecond precision `"YYYY-MM-DDThh:mm:ss.fff"`
       * @type {string}
       */
      value: {
        type: String,
        notify: true,
        value: "",
        observer: "__valueChanged",
        sync: true
      },
      /**
       * The earliest allowed value (date and time) that can be selected. All earlier values will be disabled.
       *
       * Supported date time format is based on ISO 8601 (without a time zone designator):
       * - Minute precision `"YYYY-MM-DDThh:mm"`
       * - Second precision `"YYYY-MM-DDThh:mm:ss"`
       * - Millisecond precision `"YYYY-MM-DDThh:mm:ss.fff"`
       *
       * @type {string | undefined}
       */
      min: {
        type: String,
        observer: "__minChanged",
        sync: true
      },
      /**
       * The latest value (date and time) that can be selected. All later values will be disabled.
       *
       * Supported date time format is based on ISO 8601 (without a time zone designator):
       * - Minute precision `"YYYY-MM-DDThh:mm"`
       * - Second precision `"YYYY-MM-DDThh:mm:ss"`
       * - Millisecond precision `"YYYY-MM-DDThh:mm:ss.fff"`
       *
       * @type {string | undefined}
       */
      max: {
        type: String,
        observer: "__maxChanged",
        sync: true
      },
      /**
       * The earliest value that can be selected. All earlier values will be disabled.
       * @private
       */
      __minDateTime: {
        type: Date,
        value: "",
        sync: true
      },
      /**
       * The latest value that can be selected. All later values will be disabled.
       * @private
       */
      __maxDateTime: {
        type: Date,
        value: "",
        sync: true
      },
      /**
       * A placeholder string for the date field.
       * @attr {string} date-placeholder
       */
      datePlaceholder: {
        type: String,
        sync: true
      },
      /**
       * A placeholder string for the time field.
       * @attr {string} time-placeholder
       */
      timePlaceholder: {
        type: String,
        sync: true
      },
      /**
       * Defines the time interval (in seconds) between the items displayed
       * in the time selection box. The default is 1 hour (i.e. `3600`).
       *
       * It also configures the precision of the time part of the value string. By default
       * the component formats time values as `hh:mm` but setting a step value
       * lower than one minute or one second, format resolution changes to
       * `hh:mm:ss` and `hh:mm:ss.fff` respectively.
       *
       * Unit must be set in seconds, and for correctly configuring intervals
       * in the dropdown, it need to evenly divide a day.
       *
       * Note: it is possible to define step that is dividing an hour in inexact
       * fragments (i.e. 5760 seconds which equals 1 hour 36 minutes), but it is
       * not recommended to use it for better UX.
       */
      step: {
        type: Number,
        sync: true
      },
      /**
       * Date which should be visible in the date picker overlay when there is no value selected.
       *
       * The same date formats as for the `value` property are supported but without the time part.
       * @attr {string} initial-position
       */
      initialPosition: {
        type: String,
        sync: true
      },
      /**
       * Set true to display ISO-8601 week numbers in the calendar. Notice that
       * displaying week numbers is only supported when `i18n.firstDayOfWeek`
       * is 1 (Monday).
       * @attr {boolean} show-week-numbers
       */
      showWeekNumbers: {
        type: Boolean,
        value: false,
        sync: true
      },
      /**
       * Set to true to prevent the overlays from opening automatically.
       * @attr {boolean} auto-open-disabled
       */
      autoOpenDisabled: {
        type: Boolean,
        sync: true
      },
      /**
       * Set to true to make this element read-only.
       * @type {boolean}
       */
      readonly: {
        type: Boolean,
        value: false,
        reflectToAttribute: true,
        sync: true
      },
      /**
       * Specify that this control should have input focus when the page loads.
       * @type {boolean}
       */
      autofocus: {
        type: Boolean
      },
      /**
       * The current selected date time.
       * @private
       */
      __selectedDateTime: {
        type: Date,
        sync: true
      },
      /**
       * The object used to localize this component.
       * To change the default localization, replace the entire
       * `i18n` object or just the properties you want to modify.
       *
       * The object is a combination of the i18n properties supported by
       * [`<vaadin-date-picker>`](#/elements/vaadin-date-picker) and
       * [`<vaadin-time-picker>`](#/elements/vaadin-time-picker).
       * @type {!DateTimePickerI18n}
       */
      i18n: {
        type: Object,
        sync: true,
        value: () => ({ ...datePickerI18nDefaults, ...timePickerI18nDefaults })
      },
      /**
       * A space-delimited list of CSS class names to set on the overlay elements
       * of the internal components controlled by the `<vaadin-date-time-picker>`:
       *
       * - [`<vaadin-date-picker>`](#/elements/vaadin-date-picker#property-overlayClass)
       * - [`<vaadin-time-picker>`](#/elements/vaadin-time-picker#property-overlayClass)
       *
       * @attr {string} overlay-class
       */
      overlayClass: {
        type: String
      },
      /**
       * The current slotted date picker.
       * @private
       */
      __datePicker: {
        type: Object,
        sync: true,
        observer: "__datePickerChanged"
      },
      /**
       * The current slotted time picker.
       * @private
       */
      __timePicker: {
        type: Object,
        sync: true,
        observer: "__timePickerChanged"
      }
    };
  }
  static get observers() {
    return [
      "__selectedDateTimeChanged(__selectedDateTime)",
      "__datePlaceholderChanged(datePlaceholder, __datePicker)",
      "__timePlaceholderChanged(timePlaceholder, __timePicker)",
      "__stepChanged(step, __timePicker)",
      "__initialPositionChanged(initialPosition, __datePicker)",
      "__showWeekNumbersChanged(showWeekNumbers, __datePicker)",
      "__requiredChanged(required, __datePicker, __timePicker)",
      "__invalidChanged(invalid, __datePicker, __timePicker)",
      "__disabledChanged(disabled, __datePicker, __timePicker)",
      "__readonlyChanged(readonly, __datePicker, __timePicker)",
      "__i18nChanged(i18n, __datePicker, __timePicker)",
      "__autoOpenDisabledChanged(autoOpenDisabled, __datePicker, __timePicker)",
      "__themeChanged(_theme, __datePicker, __timePicker)",
      "__overlayClassChanged(overlayClass, __datePicker, __timePicker)",
      "__pickersChanged(__datePicker, __timePicker)",
      "__labelOrAccessibleNameChanged(label, accessibleName, i18n, __datePicker, __timePicker)"
    ];
  }
  constructor() {
    super();
    this.__defaultDateMinMaxValue = void 0;
    this.__defaultTimeMinValue = "00:00:00.000";
    this.__defaultTimeMaxValue = "23:59:59.999";
    this.__onGlobalClick = this.__onGlobalClick.bind(this);
    this.__changeEventHandler = this.__changeEventHandler.bind(this);
    this.__valueChangedEventHandler = this.__valueChangedEventHandler.bind(this);
    this.__openedChangedEventHandler = this.__openedChangedEventHandler.bind(this);
  }
  /** @private */
  get __pickers() {
    return [this.__datePicker, this.__timePicker];
  }
  /** @private */
  get __filledPickers() {
    return this.__pickers.filter((picker) => picker.value || picker.__unparsableValue);
  }
  /** @private */
  get __formattedValue() {
    const values = this.__pickers.map((picker) => picker.value);
    return values.every(Boolean) ? values.join("T") : "";
  }
  /**
   * Values:
   * - ""
   * - "fooT"
   * - "Tbar"
   * - "fooTbar"
   * - "T12:00"
   * - "fooT12:00"
   * - "2024-01-01T"
   * - "2024-01-01Tbar"
   *
   * @private
   */
  get __unparsableValue() {
    if (this.__filledPickers.length > 0 && !this.__pickers.every((picker) => picker.value)) {
      return this.__pickers.map((picker) => picker.value || picker.__unparsableValue).join("T");
    }
    return "";
  }
  /** @protected */
  ready() {
    super.ready();
    this._datePickerController = new PickerSlotController(this, "date");
    this.addController(this._datePickerController);
    this._timePickerController = new PickerSlotController(this, "time");
    this.addController(this._timePickerController);
    if (this.autofocus && !this.disabled) {
      window.requestAnimationFrame(() => this.focus());
    }
    this.setAttribute("role", "group");
    this._tooltipController = new TooltipController(this);
    this.addController(this._tooltipController);
    this._tooltipController.setPosition("top");
    this._tooltipController.setShouldShow((target) => {
      return target.__datePicker && !target.__datePicker.opened && target.__timePicker && !target.__timePicker.opened;
    });
    this.ariaTarget = this;
  }
  /** @protected */
  connectedCallback() {
    super.connectedCallback();
    document.addEventListener("click", this.__onGlobalClick, true);
  }
  /** @protected */
  disconnectedCallback() {
    super.disconnectedCallback();
    document.removeEventListener("click", this.__onGlobalClick, true);
  }
  /**
   * @param {FocusOptions=} options
   * @protected
   * @override
   */
  focus(options) {
    if (this.__datePicker) {
      this.__datePicker.focus(options);
    }
  }
  /** @private */
  __onGlobalClick(event) {
    const isOpened = this.__datePicker.opened || this.__timePicker.opened;
    if (!isOpened) {
      return;
    }
    const isOutsideClick = event.composedPath().every((node) => {
      return ![
        this.__datePicker,
        this.__datePicker.$.overlay,
        this.__timePicker,
        this.__timePicker.$.comboBox.$.overlay
      ].includes(node);
    });
    if (isOutsideClick) {
      this.__outsideClickInProgress = true;
      setTimeout(() => {
        this.__outsideClickInProgress = false;
      });
    }
  }
  /**
   * Override method inherited from `FocusMixin` to validate on blur.
   * @param {boolean} focused
   * @protected
   * @override
   */
  _setFocused(focused) {
    super._setFocused(focused);
    if (!focused && document.hasFocus()) {
      this.__commitPendingValueChange();
    }
  }
  /**
   * Override method inherited from `FocusMixin` to not remove focused
   * state when focus moves between pickers or to the overlay.
   * @param {FocusEvent} event
   * @return {boolean}
   * @protected
   * @override
   */
  _shouldRemoveFocus(event) {
    const target = event.relatedTarget;
    if (this.__datePicker.opened || this.__timePicker.opened || this.__datePicker.contains(target) || this.__timePicker.contains(target)) {
      return false;
    }
    return true;
  }
  /** @private */
  __syncI18n(target, source, props = Object.keys(source.i18n)) {
    const i18n = { ...target.i18n };
    props.forEach((prop) => {
      if (source.i18n && source.i18n.hasOwnProperty(prop)) {
        i18n[prop] = source.i18n[prop];
      }
    });
    target.i18n = i18n;
  }
  /** @private */
  __changeEventHandler(event) {
    event.stopPropagation();
    const isAlreadyInvalid = this.invalid;
    const filledPickers = this.__filledPickers;
    if (filledPickers.length === 1 && filledPickers[0].checkValidity() && !isAlreadyInvalid) {
      return;
    }
    if (this.__hasPendingValueChange) {
      this.__commitPendingValueChange();
    }
  }
  /** @private */
  __openedChangedEventHandler() {
    const opened = this.__datePicker.opened || this.__timePicker.opened;
    this.style.pointerEvents = opened ? "auto" : "";
    if (!opened && this.__outsideClickInProgress) {
      this.__commitPendingValueChange();
    }
  }
  /** @private */
  __addInputListeners(node) {
    node.addEventListener("change", this.__changeEventHandler);
    node.addEventListener("unparsable-change", this.__changeEventHandler);
    node.addEventListener("value-changed", this.__valueChangedEventHandler);
    node.addEventListener("opened-changed", this.__openedChangedEventHandler);
  }
  /** @private */
  __removeInputListeners(node) {
    node.removeEventListener("change", this.__changeEventHandler);
    node.removeEventListener("unparsable-change", this.__changeEventHandler);
    node.removeEventListener("value-changed", this.__valueChangedEventHandler);
    node.removeEventListener("opened-changed", this.__openedChangedEventHandler);
  }
  /** @private */
  __isDefaultPicker(picker, type) {
    const controller = this[`_${type}PickerController`];
    return controller && picker === controller.defaultNode;
  }
  /** @private */
  __datePickerChanged(newDatePicker, existingDatePicker) {
    if (!newDatePicker) {
      return;
    }
    if (existingDatePicker) {
      this.__removeInputListeners(existingDatePicker);
      existingDatePicker.remove();
    }
    this.__addInputListeners(newDatePicker);
    if (!this.__isDefaultPicker(newDatePicker, "date")) {
      this.datePlaceholder = newDatePicker.placeholder;
      this.initialPosition = newDatePicker.initialPosition;
      this.showWeekNumbers = newDatePicker.showWeekNumbers;
      this.__syncI18n(this, newDatePicker, datePickerI18nProps);
    }
    newDatePicker.min = this.__formatDateISO(this.__minDateTime, this.__defaultDateMinMaxValue);
    newDatePicker.max = this.__formatDateISO(this.__maxDateTime, this.__defaultDateMinMaxValue);
    newDatePicker.manualValidation = true;
  }
  /** @private */
  __timePickerChanged(newTimePicker, existingTimePicker) {
    if (!newTimePicker) {
      return;
    }
    if (existingTimePicker) {
      this.__removeInputListeners(existingTimePicker);
      existingTimePicker.remove();
    }
    this.__addInputListeners(newTimePicker);
    if (!this.__isDefaultPicker(newTimePicker, "time")) {
      this.timePlaceholder = newTimePicker.placeholder;
      this.step = newTimePicker.step;
      this.__syncI18n(this, newTimePicker, timePickerI18nProps);
    }
    this.__updateTimePickerMinMax();
    newTimePicker.manualValidation = true;
  }
  /** @private */
  __updateTimePickerMinMax() {
    if (this.__timePicker && this.__datePicker) {
      const selectedDate = this.__parseDate(this.__datePicker.value);
      const isMinMaxSameDay = dateEquals(this.__minDateTime, this.__maxDateTime, normalizeUTCDate);
      if (this.__minDateTime && dateEquals(selectedDate, this.__minDateTime, normalizeUTCDate) || isMinMaxSameDay) {
        this.__timePicker.min = this.__dateToIsoTimeString(this.__minDateTime);
      } else {
        this.__timePicker.min = this.__defaultTimeMinValue;
      }
      if (this.__maxDateTime && dateEquals(selectedDate, this.__maxDateTime, normalizeUTCDate) || isMinMaxSameDay) {
        this.__timePicker.max = this.__dateToIsoTimeString(this.__maxDateTime);
      } else {
        this.__timePicker.max = this.__defaultTimeMaxValue;
      }
    }
  }
  /** @private */
  __i18nChanged(_i18n, datePicker, timePicker) {
    if (datePicker) {
      this.__syncI18n(datePicker, this, datePickerI18nProps);
    }
    if (timePicker) {
      this.__syncI18n(timePicker, this, timePickerI18nProps);
    }
  }
  /** @private */
  __labelOrAccessibleNameChanged(label, accessibleName, i18n, datePicker, timePicker) {
    const name = accessibleName || label || "";
    if (datePicker) {
      datePicker.accessibleName = `${name} ${i18n.dateLabel || ""}`.trim();
    }
    if (timePicker) {
      timePicker.accessibleName = `${name} ${i18n.timeLabel || ""}`.trim();
    }
  }
  /** @private */
  __datePlaceholderChanged(datePlaceholder, datePicker) {
    if (datePicker) {
      datePicker.placeholder = datePlaceholder;
    }
  }
  /** @private */
  __timePlaceholderChanged(timePlaceholder, timePicker) {
    if (timePicker) {
      timePicker.placeholder = timePlaceholder;
    }
  }
  /** @private */
  __stepChanged(step, timePicker) {
    if (timePicker && timePicker.step !== step) {
      timePicker.step = step;
    }
  }
  /** @private */
  __initialPositionChanged(initialPosition, datePicker) {
    if (datePicker) {
      datePicker.initialPosition = initialPosition;
    }
  }
  /** @private */
  __showWeekNumbersChanged(showWeekNumbers, datePicker) {
    if (datePicker) {
      datePicker.showWeekNumbers = showWeekNumbers;
    }
  }
  /** @private */
  __invalidChanged(invalid, datePicker, timePicker) {
    if (datePicker) {
      datePicker.invalid = invalid;
    }
    if (timePicker) {
      timePicker.invalid = invalid;
    }
  }
  /** @private */
  __requiredChanged(required, datePicker, timePicker) {
    if (datePicker) {
      datePicker.required = required;
    }
    if (timePicker) {
      timePicker.required = required;
    }
    if (this.__oldRequired && !required) {
      this._requestValidation();
    }
    this.__oldRequired = required;
  }
  /** @private */
  __disabledChanged(disabled, datePicker, timePicker) {
    if (datePicker) {
      datePicker.disabled = disabled;
    }
    if (timePicker) {
      timePicker.disabled = disabled;
    }
  }
  /** @private */
  __readonlyChanged(readonly, datePicker, timePicker) {
    if (datePicker) {
      datePicker.readonly = readonly;
    }
    if (timePicker) {
      timePicker.readonly = readonly;
    }
  }
  /**
   * String (ISO date) to Date object
   * @param {string} str e.g. 'yyyy-mm-dd'
   * @return {Date | undefined}
   * @private
   */
  __parseDate(str) {
    return parseUTCDate(str);
  }
  /**
   * Date object to string (ISO date)
   * @param {Date} date
   * @param {string} defaultValue
   * @return {string} e.g. 'yyyy-mm-dd' (or defaultValue when date is falsy)
   * @private
   */
  __formatDateISO(date, defaultValue) {
    if (!date) {
      return defaultValue;
    }
    return formatUTCISODate(date);
  }
  /**
   * String (ISO date time) to Date object
   * @param {string} str e.g. 'yyyy-mm-ddThh:mm', 'yyyy-mm-ddThh:mm:ss', 'yyyy-mm-ddThh:mm:ss.fff'
   * @return {Date | undefined}
   * @private
   */
  __parseDateTime(str) {
    const [dateValue, timeValue] = str.split("T");
    if (!(dateValue && timeValue)) {
      return;
    }
    const date = this.__parseDate(dateValue);
    if (!date) {
      return;
    }
    const time = parseISOTime(timeValue);
    if (!time) {
      return;
    }
    date.setUTCHours(parseInt(time.hours));
    date.setUTCMinutes(parseInt(time.minutes || 0));
    date.setUTCSeconds(parseInt(time.seconds || 0));
    date.setUTCMilliseconds(parseInt(time.milliseconds || 0));
    return date;
  }
  /**
   * Date object to string (ISO date time)
   * @param {Date} date
   * @return {string} e.g. 'yyyy-mm-ddThh:mm', 'yyyy-mm-ddThh:mm:ss', 'yyyy-mm-ddThh:mm:ss.fff'
   *                  (depending on precision defined by "step" property)
   * @private
   */
  __formatDateTime(date) {
    if (!date) {
      return "";
    }
    const dateValue = this.__formatDateISO(date, "");
    const timeValue = this.__dateToIsoTimeString(date);
    return `${dateValue}T${timeValue}`;
  }
  /**
   * Date object to string (ISO time)
   * @param {Date} date
   * @return {string} e.g. 'hh:mm', 'hh:mm:ss', 'hh:mm:ss.fff' (depending on precision defined by "step" property)
   * @private
   */
  __dateToIsoTimeString(date) {
    return formatISOTime(
      validateTime(
        {
          hours: date.getUTCHours(),
          minutes: date.getUTCMinutes(),
          seconds: date.getUTCSeconds(),
          milliseconds: date.getUTCMilliseconds()
        },
        this.step
      )
    );
  }
  /**
   * Returns true if the current input value satisfies all constraints (if any)
   *
   * You can override the `checkValidity` method for custom validations.
   * @return {boolean}
   */
  checkValidity() {
    const hasInvalidPickers = this.__pickers.some((picker) => !picker.checkValidity());
    const hasOnlyOneFilledPicker = this.__filledPickers.length === 1;
    const hasEmptyRequiredPickers = this.required && this.__pickers.some((picker) => !picker.value);
    return !hasInvalidPickers && !hasEmptyRequiredPickers && !hasOnlyOneFilledPicker;
  }
  /** @private */
  __commitPendingValueChange() {
    this._requestValidation();
    if (this.__committedValue !== this.value) {
      this.dispatchEvent(new CustomEvent("change", { bubbles: true }));
    } else if (this.__committedUnparsableValue !== this.__unparsableValue) {
      this.dispatchEvent(new CustomEvent("unparsable-change"));
    }
    this.__committedValue = this.value;
    this.__committedUnparsableValue = this.__unparsableValue;
  }
  /** @private */
  get __hasPendingValueChange() {
    return this.__committedValue !== this.value || this.__committedUnparsableValue !== this.__unparsableValue;
  }
  /**
   * @param {Date} date1
   * @param {Date} date2
   * @return {boolean}
   * @private
   */
  __dateTimeEquals(date1, date2) {
    if (!dateEquals(date1, date2, normalizeUTCDate)) {
      return false;
    }
    return date1.getUTCHours() === date2.getUTCHours() && date1.getUTCMinutes() === date2.getUTCMinutes() && date1.getUTCSeconds() === date2.getUTCSeconds() && date1.getUTCMilliseconds() === date2.getUTCMilliseconds();
  }
  /** @private */
  __handleDateTimeChange(property, parsedProperty, value, oldValue) {
    if (!value) {
      this[property] = "";
      this[parsedProperty] = "";
      return;
    }
    const dateTime = this.__parseDateTime(value);
    if (!dateTime) {
      this[property] = oldValue;
      return;
    }
    if (!this.__dateTimeEquals(this[parsedProperty], dateTime)) {
      this[parsedProperty] = dateTime;
    }
  }
  /** @private */
  __valueChanged(value, oldValue) {
    this.__handleDateTimeChange("value", "__selectedDateTime", value, oldValue);
    if (!this.__keepCommittedValue) {
      this.__committedValue = value;
      this.__committedUnparsableValue = "";
    }
    this.toggleAttribute("has-value", !!value);
    this.__updateTimePickerMinMax();
  }
  /** @private */
  __dispatchChange() {
    this.dispatchEvent(new CustomEvent("change", { bubbles: true }));
  }
  /** @private */
  __minChanged(value, oldValue) {
    this.__handleDateTimeChange("min", "__minDateTime", value, oldValue);
    if (this.__datePicker) {
      this.__datePicker.min = this.__formatDateISO(this.__minDateTime, this.__defaultDateMinMaxValue);
    }
    this.__updateTimePickerMinMax();
    if (this.__datePicker && this.__timePicker && this.value) {
      this._requestValidation();
    }
  }
  /** @private */
  __maxChanged(value, oldValue) {
    this.__handleDateTimeChange("max", "__maxDateTime", value, oldValue);
    if (this.__datePicker) {
      this.__datePicker.max = this.__formatDateISO(this.__maxDateTime, this.__defaultDateMinMaxValue);
    }
    this.__updateTimePickerMinMax();
    if (this.__datePicker && this.__timePicker && this.value) {
      this._requestValidation();
    }
  }
  /** @private */
  __selectedDateTimeChanged(selectedDateTime) {
    const formattedValue = this.__formatDateTime(selectedDateTime);
    if (this.value !== formattedValue) {
      this.value = formattedValue;
    }
    const isDatePickerReady = Boolean(this.__datePicker && this.__datePicker.$);
    if (isDatePickerReady && !this.__ignoreInputValueChange) {
      this.__ignoreInputValueChange = true;
      const [dateValue, timeValue] = this.value.split("T");
      this.__datePicker.value = dateValue || "";
      this.__timePicker.value = timeValue || "";
      this.__ignoreInputValueChange = false;
    }
  }
  /** @private */
  __valueChangedEventHandler() {
    if (this.__ignoreInputValueChange) {
      return;
    }
    this.__ignoreInputValueChange = true;
    this.__keepCommittedValue = true;
    this.__updateTimePickerMinMax();
    this.value = this.__formattedValue;
    this.__keepCommittedValue = false;
    this.__ignoreInputValueChange = false;
  }
  /** @private */
  __autoOpenDisabledChanged(autoOpenDisabled, datePicker, timePicker) {
    if (datePicker) {
      datePicker.autoOpenDisabled = autoOpenDisabled;
    }
    if (timePicker) {
      timePicker.autoOpenDisabled = autoOpenDisabled;
    }
  }
  /** @private */
  __themeChanged(theme, datePicker, timePicker) {
    if (!datePicker || !timePicker) {
      return;
    }
    [datePicker, timePicker].forEach((picker) => {
      if (theme) {
        picker.setAttribute("theme", theme);
      } else {
        picker.removeAttribute("theme");
      }
    });
  }
  /** @private */
  __overlayClassChanged(overlayClass, datePicker, timePicker) {
    if (!datePicker || !timePicker) {
      return;
    }
    datePicker.overlayClass = overlayClass;
    timePicker.overlayClass = overlayClass;
  }
  /** @private */
  __pickersChanged(datePicker, timePicker) {
    if (!datePicker || !timePicker) {
      return;
    }
    if (this.__isDefaultPicker(datePicker, "date") !== this.__isDefaultPicker(timePicker, "time")) {
      return;
    }
    if (datePicker.value) {
      this.__valueChangedEventHandler();
    } else if (this.value) {
      this.__selectedDateTimeChanged(this.__selectedDateTime);
      if (this.min && this.__minDateTime || this.max && this.__maxDateTime) {
        this._requestValidation();
      }
    }
  }
  /**
   * Fired when the user commits a value change.
   *
   * @event change
   */
};

// node_modules/@vaadin/date-time-picker/src/vaadin-date-time-picker.js
registerStyles("vaadin-date-time-picker", inputFieldShared, { moduleId: "vaadin-date-time-picker" });
var DateTimePicker = class extends DateTimePickerMixin(ThemableMixin(ElementMixin(PolymerElement))) {
  static get template() {
    return html`
      <style>
        .vaadin-date-time-picker-container {
          --vaadin-field-default-width: auto;
        }

        .slots {
          display: flex;
          --vaadin-field-default-width: 12em;
        }

        .slots ::slotted([slot='date-picker']) {
          min-width: 0;
          flex: 1 1 auto;
        }

        .slots ::slotted([slot='time-picker']) {
          min-width: 0;
          flex: 1 1.65 auto;
        }
      </style>

      <div class="vaadin-date-time-picker-container">
        <div part="label" on-click="focus">
          <slot name="label"></slot>
          <span part="required-indicator" aria-hidden="true"></span>
        </div>

        <div class="slots">
          <slot name="date-picker" id="dateSlot"></slot>
          <slot name="time-picker" id="timeSlot"></slot>
        </div>

        <div part="helper-text">
          <slot name="helper"></slot>
        </div>

        <div part="error-message">
          <slot name="error-message"></slot>
        </div>
      </div>

      <slot name="tooltip"></slot>
    `;
  }
  static get is() {
    return "vaadin-date-time-picker";
  }
};
defineCustomElement(DateTimePicker);
/*! Bundled license information:

@vaadin/date-time-picker/src/vaadin-date-time-picker-mixin.js:
@vaadin/date-time-picker/src/vaadin-date-time-picker.js:
  (**
   * @license
   * Copyright (c) 2019 - 2025 Vaadin Ltd.
   * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
   *)
*/
//# sourceMappingURL=@vaadin_date-time-picker_theme_lumo_vaadin-date-time-picker__js.js.map

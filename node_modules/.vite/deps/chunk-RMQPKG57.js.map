{
  "version": 3,
  "sources": ["../../@vaadin/vaadin-themable-mixin/vaadin-theme-property-mixin.js", "../../@vaadin/vaadin-themable-mixin/src/css-utils.js", "../../@vaadin/vaadin-themable-mixin/vaadin-themable-mixin.js"],
  "sourcesContent": ["/**\n * @license\n * Copyright (c) 2017 - 2025 Vaadin Ltd.\n * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/\n */\n/**\n * @polymerMixin\n */\nexport const ThemePropertyMixin = (superClass) =>\n  class VaadinThemePropertyMixin extends superClass {\n    static get properties() {\n      return {\n        /**\n         * Helper property with theme attribute value facilitating propagation\n         * in shadow DOM.\n         *\n         * Enables the component implementation to propagate the `theme`\n         * attribute value to the sub-components in Shadow DOM by binding\n         * the sub-component's \"theme\" attribute to the `theme` property of\n         * the host.\n         *\n         * **NOTE:** Extending the mixin only provides the property for binding,\n         * and does not make the propagation alone.\n         *\n         * See [Styling Components: Sub-components](https://vaadin.com/docs/latest/styling/styling-components/#sub-components).\n         * page for more information.\n         *\n         * @protected\n         */\n        _theme: {\n          type: String,\n          readOnly: true,\n        },\n      };\n    }\n\n    static get observedAttributes() {\n      return [...super.observedAttributes, 'theme'];\n    }\n\n    /** @protected */\n    attributeChangedCallback(name, oldValue, newValue) {\n      super.attributeChangedCallback(name, oldValue, newValue);\n\n      if (name === 'theme') {\n        this._set_theme(newValue);\n      }\n    }\n  };\n", "/**\n * @license\n * Copyright (c) 2021 - 2025 Vaadin Ltd.\n * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/\n */\nimport { adoptStyles } from 'lit';\n\n/**\n * Returns the effective styles that should apply to the component\n * in the correct order, to place injected stylesheet after styles\n * defined with `static styles` and before any custom theme styles\n * that the user provided using `registerStyles()` function.\n *\n * @param {HTMLElement} component\n * @return {CSSStyleSheet[]}\n */\nfunction getEffectiveStyles(component) {\n  const componentClass = component.constructor;\n\n  const styleSheet = component.__cssInjectorStyleSheet;\n  if (styleSheet) {\n    return [...componentClass.baseStyles, styleSheet, ...componentClass.themeStyles];\n  }\n\n  return componentClass.elementStyles;\n}\n\n/**\n * Apply styles on the instance of the component in the correct order.\n *\n * @param {HTMLElement} component\n */\nexport function applyInstanceStyles(component) {\n  // The adoptStyles function may fall back to appending style elements to shadow root.\n  // Remove them first to avoid duplicates.\n  [...component.shadowRoot.querySelectorAll('style')].forEach((style) => style.remove());\n\n  adoptStyles(component.shadowRoot, getEffectiveStyles(component));\n}\n\n/**\n * Injects the given stylesheet into the shadow root of the component\n * through the adoptedStyleSheets API. This will override any styles\n * that were injected previously since we only expect one stylesheet\n * to be injected into each component.\n *\n * @param {HTMLElement} component\n * @param {CSSStyleSheet} styleSheet\n */\nexport function injectStyleSheet(component, styleSheet) {\n  // Store the new stylesheet so that it can be removed later.\n  component.__cssInjectorStyleSheet = styleSheet;\n  applyInstanceStyles(component);\n}\n\n/**\n * Removes the stylesheet from the component's shadow root that was added\n * by the `injectStyleSheet` function.\n *\n * @param {HTMLElement} component\n */\nexport function cleanupStyleSheet(component) {\n  const adoptedStyleSheets = component.shadowRoot.adoptedStyleSheets.filter(\n    (s) => s !== component.__cssInjectorStyleSheet,\n  );\n\n  component.shadowRoot.adoptedStyleSheets = adoptedStyleSheets;\n  component.__cssInjectorStyleSheet = undefined;\n}\n", "/**\n * @license\n * Copyright (c) 2017 - 2025 Vaadin Ltd.\n * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/\n */\nimport { css, CSSResult, LitElement, unsafeCSS } from 'lit';\nimport { applyInstanceStyles } from './src/css-utils.js';\nimport { ThemePropertyMixin } from './vaadin-theme-property-mixin.js';\n\nexport { css, unsafeCSS };\n\n/**\n * @typedef {Object} Theme\n * @property {string} themeFor\n * @property {CSSResult[]} styles\n * @property {string | string[]} [include]\n * @property {string} [moduleId]\n *\n * @typedef {CSSResult[] | CSSResult} CSSResultGroup\n */\n\n/**\n * @type {Theme[]}\n */\nconst themeRegistry = [];\n\n/**\n * @type {WeakRef<HTMLElement>[]}\n */\nconst themableInstances = new Set();\n\n/**\n * @type {string[]}\n */\nconst themableTagNames = new Set();\n\n/**\n * Check if the custom element type has themes applied.\n * @param {Function} elementClass\n * @returns {boolean}\n */\nfunction classHasThemes(elementClass) {\n  return elementClass && Object.prototype.hasOwnProperty.call(elementClass, '__themes');\n}\n\n/**\n * Check if the custom element type has themes applied.\n * @param {string} tagName\n * @returns {boolean}\n */\nfunction hasThemes(tagName) {\n  return classHasThemes(customElements.get(tagName));\n}\n\n/**\n * Flattens the styles into a single array of styles.\n * @param {CSSResultGroup} styles\n * @param {CSSResult[]} result\n * @returns {CSSResult[]}\n */\nfunction flattenStyles(styles = []) {\n  return [styles].flat(Infinity).filter((style) => {\n    if (style instanceof CSSResult) {\n      return true;\n    }\n    console.warn('An item in styles is not of type CSSResult. Use `unsafeCSS` or `css`.');\n    return false;\n  });\n}\n\n/**\n * Returns true if the themeFor string matches the tag name\n * @param {string} themeFor\n * @param {string} tagName\n * @returns {boolean}\n */\nfunction matchesThemeFor(themeFor, tagName) {\n  return (themeFor || '').split(' ').some((themeForToken) => {\n    return new RegExp(`^${themeForToken.split('*').join('.*')}$`, 'u').test(tagName);\n  });\n}\n\n/**\n * Returns the CSS text content from an array of CSSResults\n * @param {CSSResult[]} styles\n * @returns {string}\n */\nfunction getCssText(styles) {\n  return styles.map((style) => style.cssText).join('\\n');\n}\n\nconst STYLE_ID = 'vaadin-themable-mixin-style';\n\n/**\n * Includes the styles to the template.\n * @param {CSSResult[]} styles\n * @param {HTMLTemplateElement} template\n */\nfunction addStylesToTemplate(styles, template) {\n  const styleEl = document.createElement('style');\n  styleEl.id = STYLE_ID;\n  styleEl.textContent = getCssText(styles);\n  template.content.appendChild(styleEl);\n}\n\n/**\n * Dynamically updates the styles of the given component instance.\n * @param {HTMLElement} instance\n */\nfunction updateInstanceStyles(instance) {\n  if (!instance.shadowRoot) {\n    return;\n  }\n\n  const componentClass = instance.constructor;\n\n  if (instance instanceof LitElement) {\n    // LitElement\n    applyInstanceStyles(instance);\n  } else {\n    // PolymerElement\n\n    // Update style element content in the shadow root\n    const style = instance.shadowRoot.getElementById(STYLE_ID);\n    const template = componentClass.prototype._template;\n    style.textContent = template.content.getElementById(STYLE_ID).textContent;\n  }\n}\n\n/**\n * Dynamically updates the styles of the instances matching the given component type.\n * @param {Function} componentClass\n */\nfunction updateInstanceStylesOfType(componentClass) {\n  // Iterate over component instances and update their styles if needed\n  themableInstances.forEach((ref) => {\n    const instance = ref.deref();\n    if (instance instanceof componentClass) {\n      updateInstanceStyles(instance);\n    } else if (!instance) {\n      // Clean up the weak reference to a GC'd instance\n      themableInstances.delete(ref);\n    }\n  });\n}\n\n/**\n * Dynamically updates the styles of the given component type.\n * @param {Function} componentClass\n */\nfunction updateComponentStyles(componentClass) {\n  if (componentClass.prototype instanceof LitElement) {\n    // Update LitElement-based component's elementStyles\n    componentClass.elementStyles = componentClass.finalizeStyles(componentClass.styles);\n  } else {\n    // Update Polymer-based component's template\n    const template = componentClass.prototype._template;\n    template.content.getElementById(STYLE_ID).textContent = getCssText(componentClass.getStylesForThis());\n  }\n\n  // Update the styles of inheriting types\n  themableTagNames.forEach((inheritingTagName) => {\n    const inheritingClass = customElements.get(inheritingTagName);\n    if (inheritingClass !== componentClass && inheritingClass.prototype instanceof componentClass) {\n      updateComponentStyles(inheritingClass);\n    }\n  });\n}\n\n/**\n * Check if the component type already has a style matching the given styles.\n *\n * @param {Function} componentClass\n * @param {CSSResultGroup} styles\n * @returns {boolean}\n */\nfunction hasMatchingStyle(componentClass, styles) {\n  const themes = componentClass.__themes;\n  if (!themes || !styles) {\n    return false;\n  }\n\n  return themes.some((theme) =>\n    theme.styles.some((themeStyle) => styles.some((style) => style.cssText === themeStyle.cssText)),\n  );\n}\n\n/**\n * Registers CSS styles for a component type. Make sure to register the styles before\n * the first instance of a component of the type is attached to DOM.\n *\n * @param {string} themeFor The local/tag name of the component type to register the styles for\n * @param {CSSResultGroup} styles The CSS style rules to be registered for the component type\n * matching themeFor and included in the local scope of each component instance\n * @param {{moduleId?: string, include?: string | string[]}} options Additional options\n * @return {void}\n */\nexport function registerStyles(themeFor, styles, options = {}) {\n  styles = flattenStyles(styles);\n\n  if (window.Vaadin && window.Vaadin.styleModules) {\n    window.Vaadin.styleModules.registerStyles(themeFor, styles, options);\n  } else {\n    themeRegistry.push({\n      themeFor,\n      styles,\n      include: options.include,\n      moduleId: options.moduleId,\n    });\n  }\n\n  if (themeFor) {\n    // Update styles of the component types that match themeFor and have already been finalized\n    themableTagNames.forEach((tagName) => {\n      if (matchesThemeFor(themeFor, tagName) && hasThemes(tagName)) {\n        const componentClass = customElements.get(tagName);\n\n        if (hasMatchingStyle(componentClass, styles)) {\n          // Show a warning if the component type already has some of the given styles\n          console.warn(`Registering styles that already exist for ${tagName}`);\n        } else if (!window.Vaadin || !window.Vaadin.suppressPostFinalizeStylesWarning) {\n          // Show a warning if the component type has already been finalized\n          console.warn(\n            `The custom element definition for \"${tagName}\" ` +\n              `was finalized before a style module was registered. ` +\n              `Ideally, import component specific style modules before ` +\n              `importing the corresponding custom element. ` +\n              `This warning can be suppressed by setting \"window.Vaadin.suppressPostFinalizeStylesWarning = true\".`,\n          );\n        }\n\n        // Update the styles of the component type\n        updateComponentStyles(componentClass);\n        // Update the styles of the component instances matching the component type\n        updateInstanceStylesOfType(componentClass);\n      }\n    });\n  }\n}\n\n/**\n * Returns all registered themes. By default the themeRegistry is returned as is.\n * In case the style-modules adapter is imported, the themes are obtained from there instead\n * @returns {Theme[]}\n */\nfunction getAllThemes() {\n  if (window.Vaadin && window.Vaadin.styleModules) {\n    return window.Vaadin.styleModules.getAllThemes();\n  }\n  return themeRegistry;\n}\n\n/**\n * Maps the moduleName to an include priority number which is used for\n * determining the order in which styles are applied.\n * @param {string} moduleName\n * @returns {number}\n */\nfunction getIncludePriority(moduleName = '') {\n  let includePriority = 0;\n  if (moduleName.startsWith('lumo-') || moduleName.startsWith('material-')) {\n    includePriority = 1;\n  } else if (moduleName.startsWith('vaadin-')) {\n    includePriority = 2;\n  }\n  return includePriority;\n}\n\n/**\n * Gets an array of CSSResults matching the include property of the theme.\n * @param {Theme} theme\n * @returns {CSSResult[]}\n */\nfunction getIncludedStyles(theme) {\n  const includedStyles = [];\n  if (theme.include) {\n    [].concat(theme.include).forEach((includeModuleId) => {\n      const includedTheme = getAllThemes().find((s) => s.moduleId === includeModuleId);\n      if (includedTheme) {\n        includedStyles.push(...getIncludedStyles(includedTheme), ...includedTheme.styles);\n      } else {\n        console.warn(`Included moduleId ${includeModuleId} not found in style registry`);\n      }\n    }, theme.styles);\n  }\n  return includedStyles;\n}\n\n/**\n * Returns an array of themes that should be used for styling a component matching\n * the tag name. The array is sorted by the include order.\n * @param {string} tagName\n * @returns {Theme[]}\n */\nfunction getThemes(tagName) {\n  const defaultModuleName = `${tagName}-default-theme`;\n\n  const themes = getAllThemes()\n    // Filter by matching themeFor properties\n    .filter((theme) => theme.moduleId !== defaultModuleName && matchesThemeFor(theme.themeFor, tagName))\n    .map((theme) => ({\n      ...theme,\n      // Prepend styles from included themes\n      styles: [...getIncludedStyles(theme), ...theme.styles],\n      // Map moduleId to includePriority\n      includePriority: getIncludePriority(theme.moduleId),\n    }))\n    // Sort by includePriority\n    .sort((themeA, themeB) => themeB.includePriority - themeA.includePriority);\n\n  if (themes.length > 0) {\n    return themes;\n  }\n  // No theme modules found, return the default module if it exists\n  return getAllThemes().filter((theme) => theme.moduleId === defaultModuleName);\n}\n\n/**\n * @polymerMixin\n * @mixes ThemePropertyMixin\n */\nexport const ThemableMixin = (superClass) =>\n  class VaadinThemableMixin extends ThemePropertyMixin(superClass) {\n    constructor() {\n      super();\n      // Store a weak reference to the instance\n      themableInstances.add(new WeakRef(this));\n    }\n\n    /**\n     * Covers PolymerElement based component styling\n     * @protected\n     */\n    static finalize() {\n      super.finalize();\n\n      if (this.is) {\n        themableTagNames.add(this.is);\n      }\n\n      // Make sure not to run the logic intended for PolymerElement when LitElement is used.\n      if (this.elementStyles) {\n        return;\n      }\n\n      const template = this.prototype._template;\n      if (!template || classHasThemes(this)) {\n        return;\n      }\n\n      addStylesToTemplate(this.getStylesForThis(), template);\n    }\n\n    /**\n     * Covers LitElement based component styling\n     *\n     * @protected\n     */\n    static finalizeStyles(styles) {\n      // Preserve the styles the user supplied via the `static get styles()` getter\n      // so that they will always be injected before styles added by `CSSInjector`.\n      this.baseStyles = styles ? [styles].flat(Infinity) : [];\n\n      // Preserve the theme styles the user supplied via the `registerStyles()` API\n      // so that they will always be injected after styles added by `CSSInjector`.\n      this.themeStyles = this.getStylesForThis();\n\n      // Merged styles are stored in `elementStyles` and passed to `adoptStyles()`.\n      return [...this.baseStyles, ...this.themeStyles];\n    }\n\n    /**\n     * Get styles for the component type\n     *\n     * @private\n     */\n    static getStylesForThis() {\n      const superClassThemes = superClass.__themes || [];\n      const parent = Object.getPrototypeOf(this.prototype);\n      const inheritedThemes = (parent ? parent.constructor.__themes : []) || [];\n      this.__themes = [...superClassThemes, ...inheritedThemes, ...getThemes(this.is)];\n      const themeStyles = this.__themes.flatMap((theme) => theme.styles);\n      // Remove duplicates\n      return themeStyles.filter((style, index) => index === themeStyles.lastIndexOf(style));\n    }\n  };\n\nexport { themeRegistry as __themeRegistry };\n"],
  "mappings": "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",
  "names": []
}
